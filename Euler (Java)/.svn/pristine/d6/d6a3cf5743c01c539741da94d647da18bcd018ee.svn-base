package problems.P051xP075;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import util.Basic;
import base.Problem;

/**
 * P061<br>
 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
 * are all figurate (polygonal) numbers and are generated by the following
 * formulae:
 * 
 * Triangle P3,n=n(n+1)/2 1, 3, 6, 10, 15, ...
 * Square P4,n=n2 1, 4, 9, 16, 25, ...
 * Pentagonal P5,n=n(3n−1)/2 1, 5, 12, 22, 35, ...
 * Hexagonal P6,n=n(2n−1) 1, 6, 15, 28, 45, ...
 * Heptagonal P7,n=n(5n−3)/2 1, 7, 18, 34, 55, ...
 * Octagonal P8,n=n(3n−2) 1, 8, 21, 40, 65, ...
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
 * interesting properties.
 * 
 * The set is cyclic, in that the last two digits of each number is the first
 * two digits of the next number (including the last number with the first).
 * Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
 * pentagonal (P5,44=2882), is represented by a different number in the set.
 * This is the only set of 4-digit numbers with this property.
 * Find the sum of the only ordered set of six cyclic 4-digit numbers for which
 * each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
 * octagonal, is represented by a different number in the set.
 * Ans:28684
 * 
 * @return
 */
public class P061 extends Problem
{
   public P061()
   {
      problemNumber = 61;
      variations = 1;
   }
   
   @Override
   protected String execute(int variation)
   {
      switch (variation)
      {
         case 0:
         case -1:
            return attempt2() + "";
      }
      return null;
   }
   
   /**
    * Brute force attack
    * @return
    */
   public int attempt()
   {
      // need six sets of two-digit numbers that can't start with 0
      // ab,bc,cd,de,ef,fa
      // ab is triangular
      // bc is square
      // cd is pentagonal
      // de is hexagonal
      // ef is heptagonal
      // fa is octagonal
      // .. not ordered in this way, though
      int[] sets = {0,0,0,0,0,0};
      for (int a = 10; a < 100; a++)
      {
         for (int b = 10; b < 100; b++)
         {
            for (int c = 10; c < 100; c++)
            {
               for (int d = 10; d < 100; d++)
               {
                  for (int e = 10; e < 100; e++)
                  {
                     for (int f = 10; f < 100; f++)
                     {
//                        System.out.println(a + "" + b + "," + b + "" + c + "," + c + "" + d + "," + d + "" + e + ","
//                              + e + "" + f + "," + f + "" + a);
                        for (int ii = 0; ii < 6; ii++)
                           sets[ii] = 0;
                        
                        for (int ii = 3; ii <= 8; ii++)
                        {
                           if (Basic.isNgonalNumber(ii,a*100+b))
                              sets[ii-3]++;
                           if (Basic.isNgonalNumber(ii,b*100+b))
                              sets[ii-3]++;
                           if (Basic.isNgonalNumber(ii,c*100+c))
                              sets[ii-3]++;
                           if (Basic.isNgonalNumber(ii,d*100+e))
                              sets[ii-3]++;
                           if (Basic.isNgonalNumber(ii,e*100+f))
                              sets[ii-3]++;
                           if (Basic.isNgonalNumber(ii,f*100+a))
                              sets[ii-3]++;
                        }
                        
                        int sum = 0;
                        for (int ii = 0; ii < 6; ii++)
                        {
                           if (sets[ii] > 0)
                              sum++;
                        }
                        if (sum == 6)
                        {
                           // found it!
                           sum = (a+b+c+d+e+f)*101;
                           System.out.println(sum + ":::" + a + "" + b + "," + b + "" + c + "," + c + "" + d + "," + d + "" + e + ","
                               + e + "" + f + "," + f + "" + a);
//                           return (a+b+c+d+e+f)*101; // (a+b+c+d+e+f)*100+a+b+c+d+e+f
                        }
                     }
                  }
               }
            }
         }
      }
      return 0;
   }
   
   /**
    * Brute force was /far/ too slow. Instead, create a list of all the possible 4 digit numbers and put 
    * them in a list where we have the structure m(0) is all the triangles, m(1) is all the squares, etc.
    * In each of those is a map from the first two digits to a list of all possible next two digits.
    * Then we check, starting with any two digit number in the key, and follow along, finding the list
    * of two digit numbers that follow it, check if those are the key of another map in the list, etc. 
    * If we get a chain of length six, we're done.
    * @return
    */
   private int attempt2()
   {
      // generate all 4 digit lists of these numbers, then split and combine them
      List<Map<Integer,List<Integer>>> m = new ArrayList<Map<Integer,List<Integer>>>();

      for (int ii = 0; ii < 6; ii++)
      {
         m.add(new HashMap<Integer,List<Integer>>());
         int n = 0;
         int idx = 1;
         while (n < 1000)
            n = (int)Basic.getNgonalNumber(ii+3, idx++);
         while (n < 10000)
         {
            int a = n / 100;
            int b = n % 100;
            if (!m.get(ii).containsKey(a))
               m.get(ii).put(a, new ArrayList<Integer>());
            m.get(ii).get(a).add(b);
            n = (int)Basic.getNgonalNumber(ii+3, idx++);
         }
      }
      
      // just start with 0
      for (int a : m.get(0).keySet())
      {
         for (int b : m.get(0).get(a))
         {
            for (int ii = 1; ii < 6; ii++)
            {
               if (!m.get(ii).containsKey(b))
                  continue;
               for (int c : m.get(ii).get(b))
               {
                  for (int jj = 1; jj < 6; jj++)
                  {
                     if (jj == ii)
                        continue;
                     if (!m.get(jj).containsKey(c))
                        continue;
                     for (int d : m.get(jj).get(c))
                     {
                        for (int kk = 1; kk < 6; kk++)
                        {
                           if (kk == ii || kk == jj)
                              continue;
                           if (!m.get(kk).containsKey(d))
                              continue;
                           for (int e : m.get(kk).get(d))
                           {
                              for (int ll = 1; ll < 6; ll++)
                              {
                                 if (ll == ii || ll == jj || ll == kk)
                                    continue;
                                 if (!m.get(ll).containsKey(e))
                                    continue;
                                 for (int f : m.get(ll).get(e))
                                 {
                                    for (int mm = 1; mm < 6; mm++)
                                    {
                                       if (mm == ii || mm == jj || mm == kk || mm == ll)
                                          continue;
                                       if (!m.get(mm).containsKey(f))
                                          continue;
                                       if (m.get(mm).get(f).contains(a))
                                       {
//                                          int sum = (a+b+c+d+e+f)*101;
//                                          System.out.println(sum + ":::" + a + "" + b + "," + b + "" + c + "," + c + "" + d + "," + d + "" + e + ","
//                                              + e + "" + f + "," + f + "" + a);
                                          return (a+b+c+d+e+f)*101; // (a+b+c+d+e+f)*100+a+b+c+d+e+f
                                       }
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      
      return 0;
   }
}
